---
title: Linux Socket 学习笔记21-带外数据1
tags:
  - 带外数据
id: 1718
comment: false
categories:
  - Linux
  - 未分类
  - 读书笔记
date: 2009-08-07 08:55:00
---

带外数据的概念
套接口API提供了一种机制，它可以让一束数据加速从常规数据之前到达接收方，这束数据就是所谓的带外数据。
带外数据的必要性
有时候我们需要处理紧急情况，这时候就需要用带外数据来实现，例如客户端想要终止正在发送的一段数据，服务器的程序还没有来的及读取这段程序，这时客户端需要发送带外数据来取消数据的发送，这样就能减少服务器的负担。
发送和接收带外数据
在发送带外数据时需要把函数send的flags参数设置为MSG_OOB。
接收带外数据分为两种情况：
单独读取带外数据
与带内数据一起读
如果采用分开读取的方式，那么带内数据到达时必须通知接收进程，同样，接收带内数据要把函数recv的flags参数设置为MSG_OOB。
下面是实现的部分代码：
?
View Code
C
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
/*
* SIGURG signal handler :
*/
static
void
sigurg
(
int
signo
)
{
int
n
;
char
buf
[
256
]
;
n
=
recv
(
s
,
buf
,
sizeof
buf
,
MSG_OOB
)
;
if
(
n
&
lt
;
0
)
bail
(
"recv(2)"
)
;
buf
[
n
]
=
0
;
printf
(
"URG '%s' (%d)
\n
"
,
buf
,
n
)
;
signal
(
SIGURG
,
sigurg
)
;
}
int
main
(
int
argc
,
char
**
argv
)
{
int
z
;
/* Status */
char
buf
[
256
]
;
/*
* 。。。
＊建立连接等等。。
*/
//取得套接口的所有权
z
=
fcntl
(
s
,
F_SETOWN
,
getpid
(
)
)
;
if
(
z
==
-
1
)
bail
(
"fcntl(2)"
)
;
/*
* Catch SIGURG :
*/
signal
(
SIGURG
,
sigurg
)
;
for
(
;;
)
{
z
=
recv
(
s
,
buf
,
sizeof
buf
,
0
)
;
if
(
z
==
-
1
)
bail
(
"recv(2)"
)
;
if
(
z
==
0
)
break
;
buf
[
z
]
=
0
;
printf
(
"rcv '%s' (%d)
\n
"
,
buf
,
z
)
;
}
close
(
s
)
;
return
0
;
}
这里要注意，其实紧急数据在TCP中的处理和普通的带外数据是有所区别的，这里有一个紧急指针的问题，具体的看书。